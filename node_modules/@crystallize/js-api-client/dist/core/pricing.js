"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.pricesForUsageOnTier = void 0;
function pricesForUsageOnTier(usage, tiers, tierType) {
    const sortedTiers = [...tiers].sort((a, b) => a.threshold - b.threshold);
    if (tierType === 'volume') {
        return volumeBasedPriceFor(usage, sortedTiers);
    }
    return graduatedBasedPriceFor(usage, sortedTiers);
}
exports.pricesForUsageOnTier = pricesForUsageOnTier;
function volumeBasedPriceFor(usage, tiers) {
    const tiersLength = tiers.length;
    for (let i = tiersLength - 1; i >= 0; i--) {
        const tier = tiers[i];
        if (usage < tier.threshold && i > 0) {
            continue;
        }
        // manage also an inexistent tier (threshold = 0)
        return { [tier.currency]: (usage >= tier.threshold ? tier.price : 0) * usage };
    }
    return { USD: 0.0 };
}
function graduatedBasedPriceFor(usage, tiers) {
    let rest = usage;
    // manage also an inexistent tier (threshold = 0)
    if (tiers[0].threshold > 0) {
        rest = Math.max(0, rest - (tiers[0].threshold - 1));
    }
    const splitUsage = tiers.map((tier, tierIndex) => {
        const limit = tiers[tierIndex + 1]?.threshold || Infinity;
        const tierUsage = rest > limit ? limit : rest;
        rest -= tierUsage;
        return {
            ...tier,
            usage: tierUsage,
        };
    });
    return splitUsage.reduce((memo, tier) => {
        return {
            ...memo,
            [tier.currency]: (memo[tier.currency] || 0.0) + tier.usage * tier.price,
        };
    }, {});
}
//# sourceMappingURL=pricing.js.map