"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createProductHydrater = void 0;
const json_to_graphql_query_1 = require("json-to-graphql-query");
const priceListBlock = {
    startDate: true,
    endDate: true,
    price: true,
    identifier: true,
    modifier: true,
    modifierType: true,
};
function byPaths(client, options) {
    return (paths, language, extraQuery, perProduct, perVariant) => {
        const productListQuery = paths.reduce((acc, path, index) => {
            acc[`product${index}`] = {
                __aliasFor: 'catalogue',
                __args: { path, language },
                name: true,
                path: true,
                __on: {
                    __typeName: 'Product',
                    vatType: {
                        name: true,
                        percent: true,
                    },
                    variants: {
                        sku: true,
                        name: true,
                        attributes: {
                            attribute: true,
                            value: true,
                        },
                        priceVariants: {
                            name: true,
                            price: true,
                            identifier: true,
                            currency: true,
                            ...(options?.priceForEveryone === true
                                ? {
                                    priceForEveryone: priceListBlock,
                                }
                                : {}),
                            ...(options?.priceList
                                ? {
                                    priceList: {
                                        __args: { identifier: options.priceList },
                                        ...priceListBlock,
                                    },
                                }
                                : {}),
                            ...(options?.marketIdentifiers
                                ? {
                                    priceFor: {
                                        __args: { marketIdentifiers: options.marketIdentifiers },
                                        ...priceListBlock,
                                    },
                                }
                                : {}),
                        },
                        ...(perVariant !== undefined ? perVariant(path, index) : {}),
                    },
                    ...(perProduct !== undefined ? perProduct(path, index) : {}),
                },
            };
            return acc;
        }, {});
        const query = {
            ...{ ...productListQuery },
            ...(extraQuery !== undefined ? extraQuery : {}),
        };
        const fetch = client.catalogueApi;
        return fetch((0, json_to_graphql_query_1.jsonToGraphQLQuery)({ query }));
    };
}
function bySkus(client, options) {
    async function getPathForSkus(skus, language) {
        const pathsSet = new Set();
        let afterCursor;
        async function getNextPage() {
            if (options?.useSyncApiForSKUs) {
                const pimAPIResponse = await client.pimApi(`query GET_PRODUCTS_BY_SKU (
                        $skus: [String!]
                        $language: String!
                        $tenantId: ID!
                        ) {
                        product {
                            getVariants(skus: $skus, language: $language, tenantId: $tenantId) {
                                sku
                                product {
                                    tree {
                                        path
                                    }
                                }
                            }
                        }
                    }`, {
                    skus: skus,
                    language,
                    tenantId: client.config.tenantId,
                });
                skus.forEach((sku) => {
                    const match = pimAPIResponse.product.getVariants.find((v) => v.sku === sku);
                    if (match) {
                        pathsSet.add(match.product.tree.path);
                    }
                });
            }
            else {
                const searchAPIResponse = await client.searchApi(`query GET_PRODUCTS_BY_SKU ($skus: [String!], $after: String, $language: String!) {
                    search (
                        after: $after
                        language: $language
                        filter: {
                            include: {
                                skus: $skus
                            }
                        }
                    ) {
                        pageInfo {
                            endCursor
                            hasNextPage
                        }
                        edges {
                            node {
                                path
                            }
                        }
                    }
                }`, {
                    skus: skus,
                    after: afterCursor,
                    language,
                });
                const { edges, pageInfo } = searchAPIResponse.search || {};
                edges?.forEach((edge) => pathsSet.add(edge.node.path));
                if (pageInfo?.hasNextPage) {
                    afterCursor = pageInfo.endCursor;
                    await getNextPage();
                }
            }
        }
        await getNextPage();
        return Array.from(pathsSet);
    }
    return async (skus, language, extraQuery, perProduct, perVariant) => {
        const paths = await getPathForSkus(skus, language);
        if (paths.length === 0) {
            const empty = skus.reduce((acc, sku, index) => {
                acc[`product${index}`] = {};
                return acc;
            }, {});
            return empty;
        }
        return byPaths(client, options)(paths, language, extraQuery, perProduct, perVariant);
    };
}
function createProductHydrater(client, options) {
    return {
        byPaths: byPaths(client, options),
        bySkus: bySkus(client, options),
    };
}
exports.createProductHydrater = createProductHydrater;
//# sourceMappingURL=hydrate.js.map