// src/content-transformer/component.tsx
import { Fragment, createContext, useContext } from "react";
import { Fragment as Fragment2, jsx, jsxs } from "react/jsx-runtime";
var Renderers = {
  link: (props) => /* @__PURE__ */ jsx("a", { href: props.metadata?.href, rel: props.metadata?.rel, target: props.metadata?.target, children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  "unordered-list": (props) => /* @__PURE__ */ jsx("ul", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  "ordered-list": (props) => /* @__PURE__ */ jsx("ol", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  list: (props) => /* @__PURE__ */ jsx("ul", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  "list-item": (props) => /* @__PURE__ */ jsx("li", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  quote: (props) => {
    if (props.kind === "block") {
      return /* @__PURE__ */ jsx("blockquote", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) });
    }
    return /* @__PURE__ */ jsx("q", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) });
  },
  paragraph: (props) => /* @__PURE__ */ jsx("p", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  preformatted: (props) => /* @__PURE__ */ jsx("pre", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  code: (props) => /* @__PURE__ */ jsx("code", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  underlined: (props) => /* @__PURE__ */ jsx("u", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  strong: (props) => /* @__PURE__ */ jsx("strong", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  emphasized: (props) => /* @__PURE__ */ jsx("em", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  div: (props) => /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  span: (props) => /* @__PURE__ */ jsx(NodeContent, { ...props }),
  "line-break": () => /* @__PURE__ */ jsx("br", {}),
  heading1: (props) => /* @__PURE__ */ jsx("h1", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  heading2: (props) => /* @__PURE__ */ jsx("h2", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  heading3: (props) => /* @__PURE__ */ jsx("h3", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  deleted: (props) => /* @__PURE__ */ jsx("del", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  subscripted: (props) => /* @__PURE__ */ jsx("sub", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  superscripted: (props) => /* @__PURE__ */ jsx("sup", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  "horizontal-line": () => /* @__PURE__ */ jsx("hr", {}),
  table: (props) => /* @__PURE__ */ jsx("table", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  "table-row": (props) => /* @__PURE__ */ jsx("tr", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  "table-cell": (props) => /* @__PURE__ */ jsx("td", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) }),
  "table-head-cell": (props) => /* @__PURE__ */ jsx("th", { children: /* @__PURE__ */ jsx(NodeContent, { ...props }) })
};
var OverridesContext = createContext(null);
var NodeContent = (props) => {
  const { textContent } = props;
  if (textContent) {
    return renderTextContent(textContent);
  }
  if (props.children) {
    return /* @__PURE__ */ jsx(Fragment2, { children: props.children.map((child, i) => /* @__PURE__ */ jsx(ContentTransformerNode, { ...child }, i)) });
  }
  return null;
};
function renderTextContent(text) {
  const partsBetweenLineBreaks = text.split(/\n/g);
  if (partsBetweenLineBreaks.length === 1) {
    return /* @__PURE__ */ jsx(Fragment2, { children: text });
  }
  return /* @__PURE__ */ jsx(Fragment2, { children: partsBetweenLineBreaks.map((part, index) => {
    const key = index.toString();
    if (index === partsBetweenLineBreaks.length - 1) {
      return /* @__PURE__ */ jsx(Fragment, { children: "part" }, key);
    }
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      part,
      /* @__PURE__ */ jsx("br", {})
    ] }, key);
  }) });
}
var ContentTransformerNode = (props) => {
  let Renderer = Renderers.span;
  const overrides = useContext(OverridesContext);
  const { type, kind, textContent } = props;
  if (type) {
    const tag = type;
    const override = overrides?.[tag];
    Renderer = override || Renderers[tag];
  }
  if (!Renderer) {
    Renderer = Renderers.span;
    if (type === "container" && kind === "block") {
      Renderer = Renderers.div;
    } else if (type === null && textContent) {
      return renderTextContent(textContent);
    }
  }
  return /* @__PURE__ */ jsx(Renderer, { ...props });
};
var ContentTransformer = ({ overrides = null, json }) => {
  if (!json) {
    return null;
  }
  if (Array.isArray(json)) {
    const nodes = json;
    return /* @__PURE__ */ jsx(OverridesContext.Provider, { value: overrides, children: nodes.map((j, i) => /* @__PURE__ */ jsx(ContentTransformerNode, { ...j }, i)) });
  }
  const node = json;
  return /* @__PURE__ */ jsx(OverridesContext.Provider, { value: overrides, children: /* @__PURE__ */ jsx(ContentTransformerNode, { ...node }) });
};

// src/image/component.tsx
import { jsx as jsx2, jsxs as jsxs2 } from "react/jsx-runtime";
function getVariantSrc(variant) {
  return `${variant.url} ${variant.width}w`;
}
var Image = ({ children, ...restOfAllProps }) => {
  const {
    src,
    url,
    sizes,
    variants,
    altText,
    alt: altPassed,
    fallbackAlt,
    caption,
    captionPassed,
    fallbackCaption,
    className,
    media,
    _availableSizes,
    _availableFormats,
    width,
    height,
    ...rest
  } = restOfAllProps;
  let vars = (variants || []).filter((v) => !!v);
  const alt = altPassed || altText || fallbackAlt || "";
  let captionString = captionPassed || caption?.html || caption?.plainText || fallbackCaption || "";
  if (url && _availableSizes && _availableFormats) {
    vars = [];
    const urlWithoutFileExtension = url.replace(/\.[^/]+$/, "");
    const match = urlWithoutFileExtension.match(/(.+)(\/)([^/]+)$/);
    if (match) {
      const [, base, , filename] = match;
      _availableSizes.forEach((size) => {
        _availableFormats.forEach((format) => {
          vars.push({
            url: `${base}/@${size}/${filename}.${format}`,
            key: `${size}.${format}`,
            width: size
          });
        });
      });
    }
  }
  const hasVariants = vars.length > 0;
  let biggestImage = vars[0];
  if (hasVariants) {
    biggestImage = vars.reduce(function(acc, v) {
      if (!acc.width || v.width > acc.width) {
        return v;
      }
      return acc;
    }, vars[0]);
  }
  const std = vars.filter((v) => v.url && !v.url.endsWith(".webp") && !v.url.endsWith(".avif"));
  const webp = vars.filter((v) => v.url && v.url.endsWith(".webp"));
  const avif = vars.filter((v) => v.url && v.url.endsWith(".avif"));
  const srcSet = std.map(getVariantSrc).join(", ");
  const srcSetWebp = webp.map(getVariantSrc).join(", ");
  const srcSetAvif = avif.map(getVariantSrc).join(", ");
  let originalFileExtension = "jpeg";
  if (std.length > 0) {
    const match = std[0].url.match(/\.(?<name>[^.]+)$/);
    originalFileExtension = match?.groups?.name || "jpeg";
    if (originalFileExtension === "jpg") {
      originalFileExtension = "jpeg";
    }
  }
  const commonProps = {
    // Ensure fallback src for older browsers
    src: src || url || (hasVariants ? std[0].url : void 0),
    alt,
    width: width ?? biggestImage?.width,
    height: height ?? biggestImage?.height
  };
  let useWebP = srcSetWebp.length > 0;
  let useAvif = srcSetAvif.length > 0;
  if (useWebP && useAvif) {
    const [firstWebp] = webp;
    const [firstAvif] = avif;
    if (firstWebp.size && firstAvif.size) {
      useAvif = firstWebp.size > firstAvif.size;
    }
  }
  if (children) {
    return children({
      srcSet,
      srcSetWebp,
      srcSetAvif,
      useAvif,
      useWebP,
      className,
      sizes,
      media,
      ...commonProps,
      ...rest,
      originalFileExtension
    });
  }
  return /* @__PURE__ */ jsxs2("figure", { className, children: [
    /* @__PURE__ */ jsxs2("picture", { children: [
      useAvif && /* @__PURE__ */ jsx2("source", { srcSet: srcSetAvif, type: "image/avif", sizes, media }),
      useWebP && /* @__PURE__ */ jsx2("source", { srcSet: srcSetWebp, type: "image/webp", sizes, media }),
      srcSet.length > 0 && /* @__PURE__ */ jsx2("source", { srcSet, type: `image/${originalFileExtension}`, sizes, media }),
      /* @__PURE__ */ jsx2("img", { ...commonProps, ...rest })
    ] }),
    !captionPassed && caption?.json ? /* @__PURE__ */ jsx2("figcaption", { children: /* @__PURE__ */ jsx2(ContentTransformer, { json: caption.json }) }) : /* @__PURE__ */ jsx2("figcaption", { children: captionString })
  ] });
};

// src/grid/grid-renderer-utils.ts
var getGridDimensions = (rows) => {
  return {
    rows: rows.length,
    cols: rows[0].columns.reduce((acc, col) => acc + col.layout.colspan, 0)
  };
};
function getPositionnableCellClassNames(cell, { rows, cols }) {
  const { colspan, rowspan, rowIndex, colIndex } = cell.layout;
  const isLastRow = rowIndex + rowspan === rows;
  const isLastCol = colIndex + colspan === cols;
  return `cell-${rowIndex}-${colIndex} ${rowIndex == 0 ? "first-row" : ""} ${colIndex == 0 ? "first-col" : ""} ${isLastRow ? "last-row" : ""} ${isLastCol ? "last-col" : ""}`.replace(/\s+/g, " ");
}
function getPositionnablRowClassNames({ rowIndex }, { rows }) {
  return `row-${rowIndex} ${rowIndex == 0 ? "first-row" : ""} ${rowIndex == rows - 1 ? "last-row" : ""}`.replace(
    /\s+/g,
    " "
  );
}

// src/grid/CSSGrid.tsx
import { jsx as jsx3, jsxs as jsxs3 } from "react/jsx-runtime";
var CSSGrid = ({
  cellComponent,
  cells,
  children,
  dimensions,
  style,
  styleForCell,
  ...props
}) => {
  const CellComponent = cellComponent;
  return /* @__PURE__ */ jsxs3(
    "div",
    {
      style: {
        display: "grid",
        gridTemplateColumns: `repeat(${dimensions.cols}, 1fr)`,
        ...style
      },
      className: "crystallize-grid crystallize-grid--css-grid",
      ...props,
      children: [
        children && children({ cells, dimensions }),
        !children && cells.map((cell, i) => {
          const defaultStyles = {
            gridColumn: `span ${cell.layout.colspan}`,
            gridRow: `span ${cell.layout.rowspan}`
          };
          const cellStyles = styleForCell ? styleForCell(cell, defaultStyles) || defaultStyles : defaultStyles;
          return /* @__PURE__ */ jsx3(
            "div",
            {
              className: `crystallize-grid__cell ${getPositionnableCellClassNames(cell, dimensions)}`,
              style: cellStyles,
              children: /* @__PURE__ */ jsx3(CellComponent, { cell, dimensions })
            },
            `cell-${i}`
          );
        })
      ]
    }
  );
};

// src/grid/RowCol.tsx
import { jsx as jsx4, jsxs as jsxs4 } from "react/jsx-runtime";
var RowCol = ({
  cellComponent,
  grid,
  children,
  dimensions,
  styleForCell,
  ...props
}) => {
  const CellComponent = cellComponent;
  return /* @__PURE__ */ jsxs4("div", { className: "crystallize-grid crystallize-row-col-table", ...props, children: [
    children && children({ grid, dimensions }),
    !children && grid.map((row, rowIndex) => {
      return /* @__PURE__ */ jsx4(
        "div",
        {
          className: `crystallize-grid-row row ${getPositionnablRowClassNames(
            { rowIndex },
            dimensions
          )}`,
          children: row.columns.map((cell, cellIndex) => {
            const cellStyles = styleForCell ? styleForCell(cell, {}) || {} : {};
            const classes = getPositionnableCellClassNames(cell, dimensions);
            return /* @__PURE__ */ jsx4(
              "div",
              {
                className: `crystallize-grid__cell col ${classes}`,
                style: cellStyles,
                children: /* @__PURE__ */ jsx4(CellComponent, { cell, dimensions })
              },
              `cell-${rowIndex}-${cellIndex}`
            );
          })
        },
        `row-${rowIndex}`
      );
    })
  ] });
};

// src/grid/Table.tsx
import { jsx as jsx5, jsxs as jsxs5 } from "react/jsx-runtime";
var Table = ({
  cellComponent,
  grid,
  children,
  dimensions,
  styleForCell,
  ...props
}) => {
  const CellComponent = cellComponent;
  return /* @__PURE__ */ jsxs5("table", { className: "crystallize-grid crystallize-grid--table", ...props, children: [
    /* @__PURE__ */ jsx5("thead", { children: /* @__PURE__ */ jsx5("tr", { children: new Array(dimensions.cols).fill(0).map((v, i) => /* @__PURE__ */ jsx5("th", {}, `th-${i}`)) }) }),
    /* @__PURE__ */ jsxs5("tbody", { children: [
      children && children({ grid, dimensions }),
      !children && grid.map((row, rowIndex) => {
        return /* @__PURE__ */ jsx5(
          "tr",
          {
            className: getPositionnablRowClassNames({ rowIndex }, dimensions),
            children: row.columns.map((cell, cellIndex) => {
              const cellStyles = styleForCell ? styleForCell(cell, {}) || {} : {};
              const classes = getPositionnableCellClassNames(cell, dimensions);
              return /* @__PURE__ */ jsx5(
                "td",
                {
                  className: `crystallize-grid__cell ${classes}`,
                  style: cellStyles,
                  rowSpan: cell.layout.rowspan,
                  colSpan: cell.layout.colspan,
                  children: /* @__PURE__ */ jsx5(CellComponent, { cell, dimensions })
                },
                `cell-${rowIndex}-${cellIndex}`
              );
            })
          },
          `row-${rowIndex}`
        );
      })
    ] })
  ] });
};

// src/grid/types.ts
var GridRenderingType = /* @__PURE__ */ ((GridRenderingType2) => {
  GridRenderingType2["Table"] = "table";
  GridRenderingType2["Div"] = "div";
  GridRenderingType2["RowCol"] = "row-col";
  GridRenderingType2["CSSGrid"] = "CSSGrid";
  return GridRenderingType2;
})(GridRenderingType || {});

// src/grid/GridRenderer.tsx
import { jsx as jsx6 } from "react/jsx-runtime";
var GridRenderer = ({
  cellComponent,
  children,
  grid,
  type = "div" /* Div */,
  styleForCell,
  ...props
}) => {
  if (!cellComponent && !children) {
    console.error("@crystallize/grid-renderer: missing \xB4cellComponent` or children function");
    return null;
  }
  if (!grid.rows.length)
    return null;
  const dimensions = getGridDimensions(grid.rows);
  if (type === "table" /* Table */) {
    return /* @__PURE__ */ jsx6(
      Table,
      {
        cellComponent,
        grid: grid.rows,
        dimensions,
        styleForCell,
        ...props,
        children
      }
    );
  }
  if (type === "row-col" /* RowCol */) {
    return /* @__PURE__ */ jsx6(
      RowCol,
      {
        cellComponent,
        grid: grid.rows,
        dimensions,
        styleForCell,
        ...props,
        children
      }
    );
  }
  const cells = grid.rows.reduce((memo, row) => memo.concat(row.columns), []);
  return /* @__PURE__ */ jsx6(
    CSSGrid,
    {
      cellComponent,
      cells,
      dimensions,
      styleForCell,
      ...props,
      children
    }
  );
};

// src/video/component.tsx
import { useState, useEffect, useRef } from "react";

// src/video/dash.ts
function supportsMediaSource() {
  let hasWebKit = "WebKitMediaSource" in window;
  let hasMediaSource = "MediaSource" in window;
  return hasWebKit || hasMediaSource;
}
var supportsDash = supportsMediaSource;
var added = false;
function getDash() {
  return new Promise((resolve) => {
    if (!added) {
      const hlsCore = document.createElement("script");
      hlsCore.src = "https://cdn.dashjs.org/latest/dash.all.min.js";
      hlsCore.defer = true;
      document.head.appendChild(hlsCore);
      added = true;
    }
    (function checkForLibraryExistence() {
      if ("dashjs" in window) {
        resolve(window.dashjs);
      } else {
        setTimeout(checkForLibraryExistence, 10);
      }
    })();
  });
}

// src/video/hls.ts
var added2 = false;
function getHls() {
  return new Promise((resolve) => {
    if (!added2) {
      const hlsCore = document.createElement("script");
      hlsCore.src = "https://cdn.jsdelivr.net/npm/hls.js@latest";
      hlsCore.defer = true;
      document.head.appendChild(hlsCore);
      added2 = true;
    }
    (function checkForLibraryExistence() {
      if ("Hls" in window) {
        resolve(
          new window.Hls({
            testBandwidth: false,
            abrEwmaDefaultEstimate: 1e6,
            abrMaxWithRealBitrate: true
          })
        );
      } else {
        setTimeout(checkForLibraryExistence, 10);
      }
    })();
  });
}

// src/video/component.tsx
import { jsx as jsx7, jsxs as jsxs6 } from "react/jsx-runtime";
function getPoster(thumbnails) {
  if (thumbnails && thumbnails.length > 0) {
    const [firstThumbnail] = thumbnails;
    if (firstThumbnail._availableSizes && firstThumbnail._availableFormats) {
      return firstThumbnail.url;
    }
    const allVariants = firstThumbnail.variants;
    const variantsNoFancyStuff = allVariants.filter((v) => !v.url.endsWith(".webp") && !v.url.endsWith(".avif"));
    return variantsNoFancyStuff.filter((v) => v.width > 500).sort((a, b) => a.width - b.width)[0].url || variantsNoFancyStuff[0].url;
  }
  return void 0;
}
var Video = ({
  playlists,
  thumbnails,
  thumbnailProps,
  videoProps,
  autoPlay,
  loop = false,
  muted = false,
  controls = true,
  poster,
  playButtonText = "Play video",
  className
}) => {
  const [showThumbnail, setShowThumbnail] = useState(true);
  const [playVideo, setPlayVideo] = useState(false);
  const [initiated, setInitiated] = useState(false);
  const ref = useRef(null);
  useEffect(() => {
    if (autoPlay) {
      const connection = navigator.connection;
      if (!connection || !connection.saveData) {
        setPlayVideo(true);
      }
    }
  }, []);
  useEffect(() => {
    if (!playVideo) {
      return;
    }
    if (initiated) {
      return;
    }
    const video = ref.current;
    if (!video) {
      throw new Error("Cannot initialize video. Unable to find the video HTML node");
    }
    video.addEventListener("playing", () => setShowThumbnail(false), {
      once: true
    });
    const startWithHighQualityVideo = function() {
      try {
        const connection = navigator.connection;
        return connection.downlink >= 5 && !connection.saveData;
      } catch (e) {
        return false;
      }
    }();
    const m3u8Src = playlists.find((p) => p.endsWith(".m3u8"));
    if (m3u8Src) {
      if (video.canPlayType("application/vnd.apple.mpegurl")) {
        video.autoplay = true;
        video.src = m3u8Src;
        setInitiated(true);
      } else {
        getHls().then((hls) => {
          hls.loadSource(m3u8Src);
          hls.attachMedia(video);
          hls.on("hlsMediaAttached", function() {
            video.muted = true;
            video.play();
          });
          setInitiated(true);
        });
      }
    } else if (supportsDash()) {
      getDash().then((dashjs) => {
        const src = playlists.find((p) => p.endsWith(".mpd"));
        if (!src) {
          throw new Error("Cannot find a valid Dash source for video");
        }
        const player = dashjs.MediaPlayer().create();
        player.initialize();
        player.updateSettings({
          debug: {
            logLevel: dashjs.Debug.LOG_LEVEL_NONE
          },
          streaming: {
            abr: {
              initialBitrate: {
                audio: -1,
                video: startWithHighQualityVideo ? 1e4 : -1
              },
              autoSwitchBitrate: { audio: true, video: true }
            }
          }
        });
        player.setAutoPlay(true);
        player.attachView(video);
        player.attachSource(src);
        setInitiated(true);
      });
    }
  }, [playVideo]);
  function onPlayClick(event) {
    event.preventDefault();
    setPlayVideo(true);
  }
  const thumbnailStyle = {
    zIndex: showThumbnail ? 2 : 1,
    opacity: showThumbnail ? 1 : 0
  };
  const posterUrl = poster || getPoster(thumbnails);
  return /* @__PURE__ */ jsxs6("div", { className: `react-video${className ? ` ${className}` : ""}`, style: { position: "relative" }, children: [
    thumbnails && thumbnails.length > 0 ? /* @__PURE__ */ jsx7(
      Image,
      {
        ...thumbnails[0],
        className: "react-video__thumbnail",
        ...thumbnailProps,
        style: thumbnailStyle
      }
    ) : /* @__PURE__ */ jsx7("div", { className: "react-video__thumbnail-placeholder", style: thumbnailStyle }),
    !playVideo && /* @__PURE__ */ jsxs6("button", { className: "react-video__play-btn", onClick: onPlayClick, children: [
      playButtonText,
      /* @__PURE__ */ jsx7("svg", { viewBox: "0 0 100 100", className: "react-video__play-icon", children: /* @__PURE__ */ jsx7("path", { d: "M78.158 51.843L25.842 82.048c-1.418.819-3.191-.205-3.191-1.843v-60.41c0-1.638 1.773-2.661 3.191-1.843l52.317 30.205c1.418.819 1.418 2.867-.001 3.686z" }) })
    ] }),
    /* @__PURE__ */ jsx7(
      "video",
      {
        className: "react-video__video",
        ref,
        controls,
        playsInline: true,
        muted,
        loop,
        poster: posterUrl,
        style: { opacity: initiated ? 1 : 0, zIndex: showThumbnail ? 1 : 2 },
        ...videoProps
      }
    )
  ] });
};
export {
  CSSGrid,
  ContentTransformer,
  ContentTransformerNode,
  GridRenderer,
  GridRenderingType,
  Image,
  NodeContent,
  OverridesContext,
  Renderers,
  RowCol,
  Table,
  Video,
  getGridDimensions,
  getPositionnablRowClassNames,
  getPositionnableCellClassNames,
  renderTextContent
};
