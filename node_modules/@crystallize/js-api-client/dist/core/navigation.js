"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createNavigationFetcher = exports.buildNestedNavigationQuery = exports.NavigationType = void 0;
const json_to_graphql_query_1 = require("json-to-graphql-query");
var NavigationType;
(function (NavigationType) {
    NavigationType[NavigationType["Tree"] = 0] = "Tree";
    NavigationType[NavigationType["Topics"] = 1] = "Topics";
})(NavigationType = exports.NavigationType || (exports.NavigationType = {}));
function nestedQuery(depth, start = 1, extraQuery) {
    const props = {
        id: true,
        name: true,
        path: true,
        ...(extraQuery !== undefined ? extraQuery(start - 1) : {}),
    };
    if (depth <= 1) {
        return props;
    }
    return {
        ...props,
        children: {
            ...nestedQuery(depth - 1, start + 1, extraQuery),
        },
    };
}
function buildQueryFor(type, path) {
    switch (type) {
        case NavigationType.Tree:
            return {
                __variables: {
                    language: 'String!',
                    path: 'String!',
                },
                tree: {
                    __aliasFor: 'catalogue',
                    __args: {
                        language: new json_to_graphql_query_1.VariableType('language'),
                        path: new json_to_graphql_query_1.VariableType('path'),
                    },
                },
            };
        case NavigationType.Topics:
            if (path === '' || path === '/') {
                return {
                    __variables: {
                        language: 'String!',
                    },
                    tree: {
                        __aliasFor: 'topics',
                        __args: {
                            language: new json_to_graphql_query_1.VariableType('language'),
                        },
                    },
                };
            }
            return {
                __variables: {
                    language: 'String!',
                    path: 'String!',
                },
                tree: {
                    __aliasFor: 'topic',
                    __args: {
                        language: new json_to_graphql_query_1.VariableType('language'),
                        path: new json_to_graphql_query_1.VariableType('path'),
                    },
                },
            };
    }
}
function fetchTree(client, type) {
    return (path, language, depth = 1, extraQuery, perLevel) => {
        const query = buildNestedNavigationQuery(type, path, depth, extraQuery, perLevel);
        return client.catalogueApi(query, { language, path });
    };
}
function buildNestedNavigationQuery(type, path, depth, extraQuery, perLevel) {
    const baseQuery = buildQueryFor(type, path);
    const query = {
        ...baseQuery,
        tree: {
            ...baseQuery.tree,
            ...nestedQuery(depth, 1, perLevel),
        },
        ...(extraQuery !== undefined ? extraQuery : {}),
    };
    return (0, json_to_graphql_query_1.jsonToGraphQLQuery)({ query });
}
exports.buildNestedNavigationQuery = buildNestedNavigationQuery;
function createNavigationFetcher(client) {
    return {
        byFolders: fetchTree(client, NavigationType.Tree),
        byTopics: fetchTree(client, NavigationType.Topics),
    };
}
exports.createNavigationFetcher = createNavigationFetcher;
//# sourceMappingURL=navigation.js.map