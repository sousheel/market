"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createDumper = void 0;
const navigation_1 = require("../navigation");
const search_1 = require("../search");
const createSpecQuery_1 = require("./createSpecQuery");
const createDumper = (apiClient, options) => {
    const dump = async () => {
        const tenantRequestId = apiClient.enqueue.pimApi((0, createSpecQuery_1.getTenantBasicQuery)(options.tenantIdentifier));
        const tenantResult = await apiClient.execute();
        const tenant = tenantResult[tenantRequestId]?.tenant?.get;
        if (apiClient.hasFailed() || !tenant) {
            throw new Error(`⛔️ You do not have access to tenant "${options.tenantIdentifier}" ⛔️`);
        }
        const defaultLanguage = tenant?.defaults?.language;
        const spec = {
            tenant: {
                id: tenant.id,
                identifier: tenant.identifier,
                staticAuthToken: tenant.staticAuthToken,
            },
            languages: {
                default: defaultLanguage ?? tenant.availableLanguages[0].code,
                availableLanguages: tenant.availableLanguages,
            },
            vatTypes: undefined,
            subscriptionPlans: undefined,
            shapes: undefined,
            priceVariants: undefined,
            stockLocations: undefined,
            topics: {},
            grids: {},
            items: {},
        };
        const queries = (0, createSpecQuery_1.getTenantQueries)(tenant.id);
        const vatTypes = apiClient.enqueue.pimApi(queries.vatTypes);
        const shapes = apiClient.enqueue.pimApi(queries.shapes);
        const priceVariants = apiClient.enqueue.pimApi(queries.priceVariantsQuery);
        const subscriptionPlans = apiClient.enqueue.pimApi(queries.subscriptionPlans);
        const stockLocations = apiClient.enqueue.pimApi(queries.stockLocations);
        const topics = spec.languages.availableLanguages.map((language) => {
            return {
                language: language.code,
                requestId: apiClient.enqueue.catalogueApi((0, navigation_1.buildNestedNavigationQuery)(navigation_1.NavigationType.Topics, '/', options.topicsDepth ?? 25, {}, () => {
                    return {
                        parentId: true,
                    };
                }), { language: language.code, path: '/' }),
            };
        });
        const grids = spec.languages.availableLanguages.map((language) => {
            return {
                language: language.code,
                requestId: apiClient.enqueue.pimApi(queries.grids, { language: language.code }),
            };
        });
        // 1. we start by the simple stuff
        do {
            const results = apiClient.hasFailed() ? await apiClient.retry() : await apiClient.execute();
            // vatTypes
            if (results[vatTypes]) {
                spec.vatTypes = results[vatTypes].tenant?.get?.vatTypes || [];
            }
            // subscriptionPlans
            if (results[subscriptionPlans]) {
                const data = results[subscriptionPlans].subscriptionPlan?.getMany || [];
                spec.subscriptionPlans = data.map((subscriptionPlan) => ({
                    identifier: subscriptionPlan.identifier,
                    name: subscriptionPlan.name || '',
                    meteredVariables: subscriptionPlan.meteredVariables?.map((meteredVariable) => ({
                        identifier: meteredVariable.identifier,
                        name: meteredVariable.name || '',
                        unit: meteredVariable.unit,
                    })) || [],
                    periods: subscriptionPlan.periods?.map((period) => ({
                        name: period.name || '',
                        initial: period.initial,
                        recurring: period.recurring,
                    })) || [],
                }));
            }
            // shapes
            if (results[shapes]) {
                spec.shapes = results[shapes].shape?.getMany || [];
            }
            // priceVariants
            if (results[priceVariants]) {
                spec.priceVariants = results[priceVariants].priceVariant?.getMany || [];
            }
            // stockLocations
            if (results[stockLocations]) {
                spec.stockLocations = results[stockLocations].stockLocation?.getMany || [];
            }
            // topics
            topics.forEach(({ language, requestId }) => {
                if (results[requestId]) {
                    spec.topics[language] = results[requestId].tree ?? [];
                }
            });
            // grids
            grids.forEach(({ language, requestId }) => {
                if (results[requestId]) {
                    const handleRow = (row) => {
                        return {
                            columns: row.columns.map((c) => ({
                                layout: c.layout,
                                item: !c.item
                                    ? null
                                    : {
                                        externalReference: c.item.tree.externalReference,
                                        cataloguePath: c.item.tree.path,
                                    },
                            })),
                        };
                    };
                    const handleGrid = (grid) => {
                        return {
                            ...grid,
                            rows: grid.rows?.map(handleRow) || [],
                        };
                    };
                    spec.grids[language] = results[requestId].grid?.getMany?.map(handleGrid) || [];
                }
            });
        } while (apiClient.hasFailed());
        apiClient.reset();
        //2. the Items
        const search = (0, search_1.createSearcher)(apiClient).search;
        let items = [];
        for (const language of spec.languages.availableLanguages) {
            // we prepare the language in the spec
            spec.items[language.code] = [];
            for await (const node of search(language.code, { path: true })) {
                items.push({
                    language: language.code,
                    requestId: apiClient.enqueue.catalogueApi(queries.GET_ITEM, {
                        language: language.code,
                        path: node.path,
                    }),
                });
            }
        }
        do {
            const results = apiClient.hasFailed() ? await apiClient.retry() : await apiClient.execute();
            items.forEach(({ language, requestId }) => {
                if (results[requestId]) {
                    spec.items[language].push(results[requestId]);
                }
            });
        } while (apiClient.hasFailed());
        return spec;
    };
    return {
        dump,
    };
};
exports.createDumper = createDumper;
//# sourceMappingURL=dumper.js.map