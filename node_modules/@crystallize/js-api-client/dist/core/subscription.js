"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSubscriptionContractManager = void 0;
const json_to_graphql_query_1 = require("json-to-graphql-query");
const subscription_1 = require("../types/subscription");
const catalogue_1 = require("./catalogue");
function convertDates(intent) {
    if (!intent.status) {
        return {
            ...intent,
        };
    }
    let results = {
        ...intent,
    };
    if (intent.status.renewAt) {
        results = {
            ...results,
            status: {
                ...results.status,
                renewAt: intent.status.renewAt.toISOString(),
            },
        };
    }
    if (intent.status.activeUntil) {
        results = {
            ...results,
            status: {
                ...results.status,
                activeUntil: intent.status.activeUntil.toISOString(),
            },
        };
    }
    return results;
}
function convertEnums(intent) {
    let results = {
        ...intent,
    };
    if (intent.initial && intent.initial.meteredVariables) {
        results = {
            ...results,
            initial: {
                ...intent.initial,
                meteredVariables: intent.initial.meteredVariables.map((variable) => {
                    return {
                        ...variable,
                        tierType: typeof variable.tierType === 'string' ? variable.tierType : variable.tierType.value,
                    };
                }),
            },
        };
    }
    if (intent.recurring && intent.recurring.meteredVariables) {
        results = {
            ...results,
            recurring: {
                ...intent.recurring,
                meteredVariables: intent.recurring.meteredVariables.map((variable) => {
                    return {
                        ...variable,
                        tierType: typeof variable.tierType === 'string' ? variable.tierType : variable.tierType.value,
                    };
                }),
            },
        };
    }
    return results;
}
function createSubscriptionContractManager(apiClient) {
    const create = async (intentSubsctiptionContract, extraResultQuery) => {
        const intent = subscription_1.createSubscriptionContractInputRequest.parse(convertEnums(intentSubsctiptionContract));
        const api = apiClient.pimApi;
        const mutation = {
            mutation: {
                subscriptionContract: {
                    create: {
                        __args: {
                            input: convertDates(intent),
                        },
                        id: true,
                        createdAt: true,
                        ...(extraResultQuery !== undefined ? extraResultQuery : {}),
                    },
                },
            },
        };
        const confirmation = await api((0, json_to_graphql_query_1.jsonToGraphQLQuery)(mutation));
        return confirmation.subscriptionContract.create;
    };
    const update = async (id, intentSubsctiptionContract, extraResultQuery) => {
        const intent = subscription_1.updateSubscriptionContractInputRequest.parse(convertEnums(intentSubsctiptionContract));
        const api = apiClient.pimApi;
        const mutation = {
            mutation: {
                subscriptionContract: {
                    update: {
                        __args: {
                            id,
                            input: convertDates(intent),
                        },
                        id: true,
                        updatedAt: true,
                        ...(extraResultQuery !== undefined ? extraResultQuery : {}),
                    },
                },
            },
        };
        const confirmation = await api((0, json_to_graphql_query_1.jsonToGraphQLQuery)(mutation));
        return confirmation.subscriptionContract.update;
    };
    /**
     * This function assumes that the variant contains the subscriptions plans
     */
    const createSubscriptionContractTemplateBasedOnVariant = async (variant, planIdentifier, periodId, priceVariantIdentifier) => {
        const matchingPlan = variant?.subscriptionPlans?.find((plan) => plan.identifier === planIdentifier);
        const matchingPeriod = matchingPlan?.periods?.find((period) => period.id === periodId);
        if (!matchingPlan || !matchingPeriod) {
            throw new Error(`Impossible to find the Subscription Plans for SKU ${variant.sku}, plan: ${planIdentifier}, period: ${periodId}`);
        }
        const getPriceVariant = (priceVariants, identifier) => {
            return priceVariants.find((priceVariant) => priceVariant.identifier === identifier);
        };
        const transformPeriod = (period) => {
            return {
                currency: getPriceVariant(period.priceVariants || [], priceVariantIdentifier)?.currency || 'USD',
                price: getPriceVariant(period.priceVariants || [], priceVariantIdentifier)?.price || 0.0,
                meteredVariables: (period.meteredVariables || []).map((meteredVariable) => {
                    return {
                        id: meteredVariable.id,
                        tierType: new json_to_graphql_query_1.EnumType(meteredVariable.tierType),
                        tiers: meteredVariable.tiers.map((tier) => {
                            return {
                                threshold: tier.threshold,
                                currency: getPriceVariant(tier.priceVariants || [], priceVariantIdentifier)
                                    ?.currency || 'USD',
                                price: getPriceVariant(tier.priceVariants || [], priceVariantIdentifier)?.price ||
                                    0.0,
                            };
                        }),
                    };
                }),
            };
        };
        const contract = {
            item: {
                sku: variant.sku,
                name: variant.name || '',
            },
            subscriptionPlan: {
                identifier: matchingPlan.identifier,
                periodId: matchingPeriod.id,
            },
            initial: !matchingPeriod.initial ? undefined : transformPeriod(matchingPeriod.initial),
            recurring: !matchingPeriod.recurring ? undefined : transformPeriod(matchingPeriod.recurring),
        };
        return contract;
    };
    /**
     * This function fetch it all
     */
    const createSubscriptionContractTemplateBasedOnVariantIdentity = async (path, productVariantIdentifier, planIdentifier, periodId, priceVariantIdentifier, language = 'en') => {
        if (!productVariantIdentifier.sku && !productVariantIdentifier.id) {
            throw new Error(`Impossible to find the Subscription Plans for Path ${path} with and empty Variant Identity`);
        }
        // let's ask the catalog for the data we need to create the subscription contract template
        const fetcher = (0, catalogue_1.createCatalogueFetcher)(apiClient);
        const builder = catalogue_1.catalogueFetcherGraphqlBuilder;
        const data = await fetcher({
            catalogue: {
                __args: {
                    path,
                    language,
                },
                __on: [
                    builder.onProduct({}, {
                        onVariant: {
                            id: true,
                            name: true,
                            sku: true,
                            ...builder.onSubscriptionPlan(),
                        },
                    }),
                ],
            },
        });
        const matchingVariant = data.catalogue?.variants?.find((variant) => {
            if (productVariantIdentifier.sku && variant.sku === productVariantIdentifier.sku) {
                return true;
            }
            if (productVariantIdentifier.id && variant.id === productVariantIdentifier.id) {
                return true;
            }
            return false;
        });
        if (!matchingVariant) {
            throw new Error(`Impossible to find the Subscription Plans for Path ${path} and Variant: (sku: ${productVariantIdentifier.sku} id: ${productVariantIdentifier.id}), plan: ${planIdentifier}, period: ${periodId} in lang: ${language}`);
        }
        return createSubscriptionContractTemplateBasedOnVariant(matchingVariant, planIdentifier, periodId, priceVariantIdentifier);
    };
    return {
        create,
        update,
        createSubscriptionContractTemplateBasedOnVariantIdentity,
        createSubscriptionContractTemplateBasedOnVariant,
    };
}
exports.createSubscriptionContractManager = createSubscriptionContractManager;
//# sourceMappingURL=subscription.js.map